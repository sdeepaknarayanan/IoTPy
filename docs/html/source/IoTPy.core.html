
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IoTPy.core package &#8212; IoTPy 1.1.0 documentation</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">IoTPy 1.1.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">IoTPy.core package</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="iotpy-core-package">
<h1>IoTPy.core package<a class="headerlink" href="#iotpy-core-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-IoTPy.core.agent">
<span id="iotpy-core-agent-module"></span><h2>IoTPy.core.agent module<a class="headerlink" href="#module-IoTPy.core.agent" title="Permalink to this headline">¶</a></h2>
<p>This module contains the Agent class. The Agent
and Stream classes are the building blocks of IoTPy.</p>
<p>The module also contains the BasicAgent class. This
class has only two parameters: call_streams and next().
When a call_stream is modified, next() is called.</p>
<p>The Agent class, in contrast to BasicAgent, has an
parameter transition() which is called when a call
stream is modified. The difference between transition()
and next() is that transition operates on lists whereas
next() operates on streams.</p>
<dl class="py class">
<dt id="IoTPy.core.agent.Agent">
<em class="property">class </em><code class="sig-prename descclassname">IoTPy.core.agent.</code><code class="sig-name descname">Agent</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">in_streams</span></em>, <em class="sig-param"><span class="n">out_streams</span></em>, <em class="sig-param"><span class="n">transition</span></em>, <em class="sig-param"><span class="n">state</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">call_streams</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.agent.Agent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>An agent is an automaton: a state-transition machine.
An agent has only one important method: the method
next() that makes the agent execute a state transition.</p>
<p>An agent has lists of:
(1) input streams,
(2) output streams and
(3) call streams.
Streams are described in Stream.py.</p>
<p>During a state transition an agent:
(1) May read values from its input streams. (Note that</p>
<blockquote>
<div><p>reading values in a stream does not change the
stream.)</p>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>Append values to the tails of its output streams.</p></li>
<li><p>Change the agent’s own state.</p></li>
</ol>
<p>When a call stream is modified the agent’s next() method
is called which causes the agent to execute a state transition.</p>
<p>The default is that every input stream is also a call stream,
i.e., the agent executes a state transition when any of its
input streams is modified.</p>
<p>You may want the agent to execute a step when some event occurs
where the event is not a change in an input stream.
For example, for performance reasons, we may want an agent to
execute state transitions periodically — for example, every
second — rather than when an input stream is modified.
In this case, the call streams will be different from
the input streams because the call streams will be the streams
that cause the agent to be woken up. For example, a call stream
that has a value appended to it every second will cause the agent
to execute a state transition every second.</p>
<dl class="simple">
<dt>in_streams<span class="classifier">list of streams</span></dt><dd><p>The list of the agent’s input streams.
This list may be empty.</p>
</dd>
<dt>out_streams<span class="classifier">list of streams</span></dt><dd><p>The list of the agent’s output streams.
This list may be empty.</p>
</dd>
<dt>call_streams<span class="classifier">list of streams</span></dt><dd><p>When a new value is added to a stream in this list
a state transition is invoked.
This the usual way in which state transitions occur.
A state transiton for an agent ag can also be
executed by calling ag.next()</p>
</dd>
<dt>state: object</dt><dd><p>The state of the agent. The state is updated after
a transition.</p>
</dd>
<dt>transition: function</dt><dd><p>This function is called by next() which
is the state-transition operation for this agent.
An agent’s state transition is specified by
its transition function.</p>
</dd>
<dt>name<span class="classifier">str, optional</span></dt><dd><p>name of this agent</p>
</dd>
</dl>
<dl>
<dt>_in_lists: list of InList</dt><dd><p>Recall that Inlist has fields: [‘list’, ‘start’, ‘stop’]
_in_lists[j].list refers to a slice of the most recent
values of the j-th input stream of this agent.
The slice into self.recent of the j-th input stream
starts at _in_lists[j].start and stops at _in_lists[j].stop.
This agent can read the following slice of self.recent of
the j-th input stream:</p>
<blockquote>
<div><p>_in_lists[j][  _in_lists[j].start :  _in_lists[j].stop  ]</p>
</div></blockquote>
<p>of the jth input stream.</p>
</dd>
<dt>_out_lists: list</dt><dd><p>The j-th element of _out_lists is the list of
values to be appended to the j-th output
stream after the state transition.</p>
</dd>
</dl>
<dl>
<dt>next()</dt><dd><dl>
<dt>Execute a state transition. The method has 3 parts:</dt><dd><ol class="lowerroman">
<li><p>set up the data structures to execute
a state transition,</p></li>
<li><p>call the transition function to:
(a) get the values to be appended to output streams,
(b) get the next state, and
(c) update ‘start’ indices for each input stream.</p>
<blockquote>
<div><p>A start index for a stream indicates that this
agent no longer accesses elements of this input
streams with indices earlier (i.e. smaller) than
‘start’. So, as far as this agent is concerned,
elements with indices earlier than start can be
discarded.</p>
</div></blockquote>
</li>
<li><p>update data structures after the transition.</p></li>
</ol>
</dd>
</dl>
</dd>
</dl>
<p>Implementation notes: The next() method of this agent is called
when any call_stream of this agent is modified. Calling the
next() method happens in the following way.</p>
<p>Step 1.  When a call_stream is modified, the agent is placed in
the queue, q_agents, of the ComputeEngine of this process. See
ComputeEngine.q_agents. This queue contains agents waiting to
execute a next() step.
Step 2. The main compute thread of this process gets agents from
this queue and calls next() on them. (See create_compute_thread()
in ComputeEngine).</p>
<dl class="py method">
<dt id="IoTPy.core.agent.Agent.halt">
<code class="sig-name descname">halt</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.agent.Agent.halt" title="Permalink to this definition">¶</a></dt>
<dd><p>The agent stops operating because it is no longer woken
up when streams are modified.</p>
</dd></dl>

<dl class="py method">
<dt id="IoTPy.core.agent.Agent.next">
<code class="sig-name descname">next</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">stream_name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.agent.Agent.next" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute the next state transition.</p>
<p>This function does the following:
Part 1: set up data structures for the state transition.
Part 2: execute the state transition by calling self.transition
Part 3: update data structures after the transition.</p>
<p>This method can be called by any agent and is
called whenever a value is appended to any
stream in call_streams</p>
<dl class="simple">
<dt>stream_name<span class="classifier">str, optional</span></dt><dd><p>A new value was appended to the stream with name
stream_name as a result of which this agent
executes a state transition. The stream_name tells this
agent the name of stream that is causing this agent
to be woken up and execute a state transition.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="IoTPy.core.agent.Agent.restart">
<code class="sig-name descname">restart</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.agent.Agent.restart" title="Permalink to this definition">¶</a></dt>
<dd><p>This function can be used only after the agent has been
halted by calling halt(). The restart is nondeterministic.
The restarted agent may re-read parts of streams that it had
read before it was halted. Also, it may skip parts of
streams that it hasn’t read. This function is rarely used
in most applications.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="IoTPy.core.agent.BasicAgent">
<em class="property">class </em><code class="sig-prename descclassname">IoTPy.core.agent.</code><code class="sig-name descname">BasicAgent</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">call_streams</span></em>, <em class="sig-param"><span class="n">next</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.agent.BasicAgent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#IoTPy.core.agent.Agent" title="IoTPy.core.agent.Agent"><code class="xref py py-class docutils literal notranslate"><span class="pre">IoTPy.core.agent.Agent</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt id="IoTPy.core.agent.InList">
<em class="property">class </em><code class="sig-prename descclassname">IoTPy.core.agent.</code><code class="sig-name descname">InList</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">list</span></em>, <em class="sig-param"><span class="n">start</span></em>, <em class="sig-param"><span class="n">stop</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.agent.InList" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></p>
<dl class="py method">
<dt id="IoTPy.core.agent.InList.list">
<em class="property">property </em><code class="sig-name descname">list</code><a class="headerlink" href="#IoTPy.core.agent.InList.list" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl class="py method">
<dt id="IoTPy.core.agent.InList.start">
<em class="property">property </em><code class="sig-name descname">start</code><a class="headerlink" href="#IoTPy.core.agent.InList.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

<dl class="py method">
<dt id="IoTPy.core.agent.InList.stop">
<em class="property">property </em><code class="sig-name descname">stop</code><a class="headerlink" href="#IoTPy.core.agent.InList.stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-IoTPy.core.compute_engine">
<span id="iotpy-core-compute-engine-module"></span><h2>IoTPy.core.compute_engine module<a class="headerlink" href="#module-IoTPy.core.compute_engine" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="IoTPy.core.compute_engine.ComputeEngine">
<em class="property">class </em><code class="sig-prename descclassname">IoTPy.core.compute_engine.</code><code class="sig-name descname">ComputeEngine</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">process</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.compute_engine.ComputeEngine" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Manages the queue of agents scheduled for execution.
When an agent has new data on which to operate, the
agent is placed on a queue called
q_agents.</p>
<dl class="simple">
<dt>name: str (optional)</dt><dd><p>The name of the process in which this ComputeEngine
operates.
A process name is required for executing multicore
computations using multicore.py</p>
</dd>
</dl>
<dl class="simple">
<dt>input_queue: multiprocessing.Queue</dt><dd><p>Elements for input streams of this thread are put
in this queue. Each element of the queue is a 2-tuple:
(stream_name, data).</p>
</dd>
<dt>name_to_stream: dict</dt><dd><p>key: stream name
value: stream
The values in name_to_stream are the in_streams of
compute_func. name_to_stream is defined in multicore().
name_to_stream[‘s’] is the stream with name ‘s’.</p>
</dd>
<dt>q_agents: multiprocessing.Queue()</dt><dd><p>The queue of agents scheduled for execution.</p>
</dd>
<dt>scheduled_agents: Set</dt><dd><p>An agent is in the set if and only if it is
in the queue, q_agent. This set is used to ensure
that each agent appears at most once in the queue.</p>
</dd>
<dt>compute_thread: threading.Thread</dt><dd><p>The compute engine runs in this thread.</p>
</dd>
<dt>lock: threading.Lock()</dt><dd><p>The lock on using scheduled_agents. Ensures
thread safety for scheduling and de-scheduling
agents.</p>
</dd>
<dt>stopped: Boolean</dt><dd><p>True if and only if this computation is stopped.
This attribute can be set to True only in the
compute_engine.</p>
</dd>
</dl>
<p>1. Implementation of functionality to get new data from
sensors and other sources. Also see:
IoTPy/IoTPy/multiprocessing/multicore.py.</p>
<p>The function create_compute_thread() creates a thread
and makes self.compute_thread that thread. This thread
gets a message from input_queue. A message is a 2-tuple:
(stream_name, data). The thread appends data to the
stream with the name stream_name. It gets the stream
from the stream’s name by looking up the dict
self.name_to_stream.</p>
<p>Incoming messages are “pickleable” provided that
the data is “pickleable”. The thread calls self.step()
which causes agents to execute their next() functions.</p>
<p>2. Implementation of execution of agents.
The queue, q_agents, is the queue of agents scheduled
for execution. The function self.step() executes a loop
to get the next agent from the queue and call its next()
function. The loop terminates when the queue becomes
empty. At that point all agents are quiescent, waiting
for more input.</p>
<p>When an agent that is executing its next() function
extends a stream s, the stream puts an agent A in
the queue, q_agents, if s is a call stream of A. So,
self.step() continues execution until all agents are
quiescent, i.e., no stream has been modified since an
agent has read it.</p>
<p>When self.step() terminates, the compute thread attempts
to get more data from input_queue. The compute thread
terminates if no data is available in input_queue.</p>
<dl class="py method">
<dt id="IoTPy.core.compute_engine.ComputeEngine.create_compute_thread">
<code class="sig-name descname">create_compute_thread</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.compute_engine.ComputeEngine.create_compute_thread" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="IoTPy.core.compute_engine.ComputeEngine.get">
<code class="sig-name descname">get</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.compute_engine.ComputeEngine.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Waits until q_agents is non-empty, and then gets
and returns the agent at the head of the queue.
Updates the set, scheduled_agents, to ensure that
the set contains exactly those agents in q_agents.</p>
<dl class="simple">
<dt>a: Agent</dt><dd><p>The agent at the head of the queue of scheduled
agents.</p>
</dd>
</dl>
<p>Get the agent at the head of the queue of agents waiting to be
executed and discard that agent from the set of
waiting-for-scheduling agents.</p>
</dd></dl>

<dl class="py method">
<dt id="IoTPy.core.compute_engine.ComputeEngine.join">
<code class="sig-name descname">join</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.compute_engine.ComputeEngine.join" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="IoTPy.core.compute_engine.ComputeEngine.put">
<code class="sig-name descname">put</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.compute_engine.ComputeEngine.put" title="Permalink to this definition">¶</a></dt>
<dd><p>Puts the agent a into q_agents if the 
agent is not already in the queue.</p>
<p>a : Agent</p>
</dd></dl>

<dl class="py method">
<dt id="IoTPy.core.compute_engine.ComputeEngine.start">
<code class="sig-name descname">start</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.compute_engine.ComputeEngine.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Starts the compute thread.
Gets stream_name, data_for_stream from input_queue and appends
the data to the stream with the specified name.</p>
</dd></dl>

<dl class="py method">
<dt id="IoTPy.core.compute_engine.ComputeEngine.step">
<code class="sig-name descname">step</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.compute_engine.ComputeEngine.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Continues executing the next() step of an
agent in the queue of agents until the queue
gets empty.
Note: Update the set, scheduled_agents, to
ensure that this set contains exactly the
agents in the queue of agents.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-IoTPy.core.helper_control">
<span id="iotpy-core-helper-control-module"></span><h2>IoTPy.core.helper_control module<a class="headerlink" href="#module-IoTPy.core.helper_control" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="IoTPy.core.helper_control.TimeAndValue">
<em class="property">class </em><code class="sig-prename descclassname">IoTPy.core.helper_control.</code><code class="sig-name descname">TimeAndValue</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">time</span></em>, <em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.helper_control.TimeAndValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></p>
<dl class="py method">
<dt id="IoTPy.core.helper_control.TimeAndValue.time">
<em class="property">property </em><code class="sig-name descname">time</code><a class="headerlink" href="#IoTPy.core.helper_control.TimeAndValue.time" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl class="py method">
<dt id="IoTPy.core.helper_control.TimeAndValue.value">
<em class="property">property </em><code class="sig-name descname">value</code><a class="headerlink" href="#IoTPy.core.helper_control.TimeAndValue.value" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="IoTPy.core.helper_control.remove_None">
<code class="sig-prename descclassname">IoTPy.core.helper_control.</code><code class="sig-name descname">remove_None</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">lst</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.helper_control.remove_None" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="IoTPy.core.helper_control.remove_novalue_and_open_multivalue">
<code class="sig-prename descclassname">IoTPy.core.helper_control.</code><code class="sig-name descname">remove_novalue_and_open_multivalue</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">l</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.helper_control.remove_novalue_and_open_multivalue" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns a list which is the
same as the input parameter l except that
(1) _no_value elements in l are deleted and
(2) each _multivalue element in l is opened</p>
<blockquote>
<div><p>i.e., for an object _multivalue(list_x)
each element of list_x appears in the
returned list.</p>
</div></blockquote>
<dl class="simple">
<dt>l<span class="classifier">list</span></dt><dd><p>A list containing arbitrary elements
including, possibly _no_value and
_multi_value</p>
</dd>
</dl>
<blockquote>
<div><p>Same as l with every _no_value object
deleted and every _multivalue object
opened up.</p>
</div></blockquote>
<blockquote>
<div><p>l = [0, 1, _no_value, 10, _multivalue([20, 30])]
The function returns:</p>
<blockquote>
<div><p>[0, 1, 10, 20, 30]</p>
</div></blockquote>
</div></blockquote>
</dd></dl>

</div>
<div class="section" id="module-IoTPy.core.stream">
<span id="iotpy-core-stream-module"></span><h2>IoTPy.core.stream module<a class="headerlink" href="#module-IoTPy.core.stream" title="Permalink to this headline">¶</a></h2>
<p>This module contains the Stream class. The
Stream and Agent classes are the building blocks
of PythonStreams.
(Version 1.5 January, 2020. Created by: K. Mani Chandy)</p>
<dl class="py class">
<dt id="IoTPy.core.stream.Stream">
<em class="property">class </em><code class="sig-prename descclassname">IoTPy.core.stream.</code><code class="sig-name descname">Stream</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">'UnnamedStream'</span></em>, <em class="sig-param"><span class="n">initial_value</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">num_in_memory</span><span class="o">=</span><span class="default_value">1048576</span></em>, <em class="sig-param"><span class="n">discard_None</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.stream.Stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A stream is a sequence of values. Agents can:
(1) Append values to the tail of stream.
(2) Read a stream.
(3) Subscribe to be notified when a stream is</p>
<blockquote>
<div><p>modified.</p>
</div></blockquote>
<p>(See Agent.py for details of agents.)</p>
<p>An agent is either asleep (inactive)
or awake (active). An agent sleeps until it is
woken up by a notification from a stream to which
the agent has subscribed.</p>
<p>When an agent wakes up it executes a method called
next(). The agent may read and write streams while it
executes this method. When execution of the method
terminates, the agent goes back to sleep. The method
is called “next” because waking up the agent causes
it to execute its next step.</p>
<p>The ONLY way in which a stream can be
modified is that values can be appended to its
tail. The length of a stream (number of elements
in its sequence) can stay the same or increase,
but never decrease. If at some point, the length
of a stream is k, then from that point onwards, the
first k elements of the stream remain unchanged.</p>
<p>Any number of agents can read or subscribe to the
same stream. A stream can be modified by more than one
agent; however, reasoning about the correctness of an
application is much simpler if a stream is modified by
exactly one agent. If a stream is modified by multiple
agents, then values may be appended to the tail of the
stream by different agents in a nondeterministic fashion.
Testing nondeterministic programs is difficult because
successive runs with the same input may produce different
outputs. For each stream, we recommend having exactly one
agent that writes the stream.</p>
<p>An agent can reade, write and subscribe to the same stream.
An agent may subscribe to a stream without reading the
stream’s values; for example the agent may subscribe to a clock
stream so that the agent is woken up whenever the clock
stream has a new value.</p>
<p>The most recent values of a stream are stored either
in a list or a NumPy array. For the NumPy array case see
the class StreamArray.</p>
<dl class="simple">
<dt>name<span class="classifier">str, optional</span></dt><dd><p>name of the stream. The name helps with debugging.
default : ‘UnnamedStream’</p>
</dd>
<dt>initial_value<span class="classifier">list or array, optional</span></dt><dd><p>The list (or array) of initial values in the
stream. 
default : []</p>
</dd>
<dt>num_in_memory: int (positive)</dt><dd><p>If the length of a stream is less than or equal
to num_in_memory then readers can read the entire
stream. If the stream length exceeds num_in_memory
then readers of the stream can read the latest
num_in_memory elements of the stream.</p>
</dd>
<dt>discard_None: Boolean (optional)</dt><dd><p>default is True
The default is that a stream does not contain None values.
If discard_None is True then None values are discarded from
the stream. If discard_None is False then the stream may
contain elements that are None.</p>
</dd>
</dl>
<dl>
<dt>recent<span class="classifier">list or NumPy array.</span></dt><dd><p>A list or array whose elements up to self.stop contain
the most recent elements of the stream.
recent is a buffer that is written and read by
agents.
recent[:stop] contains the most recent elements of
the stream. The elements of recent[stop:] are garbage.
The length of recent is: num_in_memory</p>
</dd>
<dt>stop<span class="classifier">int</span></dt><dd><dl class="simple">
<dt>index into the list recent.</dt><dd><p>0 &lt;= stop &lt; len(self.recent) = num_in_memory</p>
</dd>
</dl>
<p>recent[:stop] contains the stop most recent
values of this stream.
recent[stop:] contains arbitrary (garbage) values.</p>
</dd>
<dt>offset: int (nonnegative)</dt><dd><p>recent is a list or array of a given length whereas
a stream can grow to an arbitrary length.
offset maps a value in a stream to a value in the buffer
self.recent.
For a stream s:</p>
<blockquote>
<div><p>s.recent[i] = s[i + s.offset] for i in range(s.stop)</p>
</div></blockquote>
<p>The length of a stream s (i.e. the number of elements in
it) is s.offset + s.stop.</p>
</dd>
<dt>start<span class="classifier">dict</span></dt><dd><p>key = reader
value = start index of the reader
The next element of stream s that reader r will read is:</p>
<blockquote>
<div><p>s.recent[s.start[r]]</p>
</div></blockquote>
<p>The usual case is that a reader r starts reading a stream s
when the stream is created, and reads at a rate that keeps
up with the rate that the stream is written. In this case
r will have read s.offset + s.start[r] elements.
If r reads s at a rate that is so slow that the size of the
buffer, recent, is too small, then r may miss reading some
elements in which case r will have read fewer than
s.recent[s.start[r]] elements.</p>
</dd>
<dt>num_elements_lost<span class="classifier">dict</span></dt><dd><p>key = reader
value = int
The value is the number of elements in the stream that the
reader missed reading because a reader read slower than the
stream was being written. If the buffer, recent, gets full
before a reader has read the first elements of the buffer
then these elements are over-written and the reader
misses reading them.</p>
</dd>
<dt>subscribers_set: set</dt><dd><p>the set of subscribers for this stream.
Subscribers are agents that are notified when
the stream is modified.
When a new subscriber r is added, s.start[r] = 0.</p>
</dd>
</dl>
<ol class="arabic simple">
<li><p>SUBSCRIBING TO A STREAM</p></li>
</ol>
<p>An agent is an object that implements a method next().
If agent x is a subscriber to a stream s then x.next()
is invoked when s is modified.</p>
<p>The only reason for an agent x to subscribe to a stream is
to be “woken up” by the call: x.next(). An agent can read
or write a stream without subscribing for it.</p>
<dl class="simple">
<dt>An agent x subscribes to a stream s by executing</dt><dd><p>s.call(x).</p>
</dd>
</dl>
<p>An agent x unsubscribes from a stream s by
executing:</p>
<blockquote>
<div><p>s.delete_caller(x)</p>
</div></blockquote>
<p>When a stream is modified, all agents that are subscribers
of the stream are put on a queue called the compute_engine queue.
The compute_engine wakes up each agent in its queue in turn.</p>
<ol class="arabic simple" start="2">
<li><p>READING A STREAM</p></li>
</ol>
<p>An agent can read a stream only after it registers
with the stream as a reader. An agents r registers
with a stream s by executing:</p>
<blockquote>
<div><p>s.register_reader(r)</p>
</div></blockquote>
<p>An agent r deletes its registration for reading s
by executing:</p>
<blockquote>
<div><p>s.delete_reader(r)</p>
</div></blockquote>
<p>In most (but not all) cases, a reader r of a stream
s wants to be woken up when s is modified. So, the
default case is: a reader of a stream is woken up
whenever the stream is modified. In some cases, however,
a reader of a stream does not want to be woken up when
the stream is modified, but wants to be woken up only
when some other event - such as the next clock tick -
occurs.</p>
<p>An agent that reads a stream is also a subscriber to
that stream unless the agent has a call-stream. 
Default Case: an agent has no call-stream.</p>
<blockquote>
<div><p>In this case the agent is woken up whenever any of
its input streams is modified.</p>
</div></blockquote>
<dl class="simple">
<dt>Non Default Case: the agent has one or more call streams.</dt><dd><p>The agent is woken up only when one of its call
streams is modified. If an input stream s is not a
call stream then the agent is not woken up when s
gets modified.</p>
</dd>
</dl>
<p>An agent r registered to read a stream s can read
the stream from its next value at index s.start[r]
to the end of the stream at index s.stop.</p>
<p>Reader r informs stream s that it will only
read values with indexes greater than or
equal to j in the list, recent,  by executing</p>
<blockquote>
<div><p>s.set_start(r, j)</p>
</div></blockquote>
<p>which makes s.start[r] to be set to j.</p>
<ol class="arabic simple" start="3">
<li><p>WRITING A STREAM</p></li>
</ol>
<p>When an agent is created it is passed a list
of streams that it can write.</p>
<p>An agent adds a single element v to a stream s
by executing:</p>
<blockquote>
<div><p>s.append(v)</p>
</div></blockquote>
<p>An agent adds the sequence of values in a list
l to a stream s by executing:</p>
<blockquote>
<div><p>s.extend(l)</p>
</div></blockquote>
<p>The operations append and extend of streams are
analogous to operations with the same names on
lists.</p>
<p>1. Implementing the functionality of mapping an
infinite stream on finite memory.</p>
<p>The elements of a stream are stored in the buffer
self.recent which is a NumPy array or a list of
fixed size num_in_memory. The most recent values
of the stream are in self.recent[: self.stop].</p>
<p>If appending values to self.recent causes self.stop
to exceed num_in_memory, then the elements in
self.recent are compacted so as to retain only the
most recent values, and the earlier values are
discarded. This is done by the function
_set_up_next_recent().</p>
<p>A reader r does not read elements of the stream
before index self.start[r]. So, no reader reads
elements of the stream before:</p>
<blockquote>
<div><p>min_start = min(self.start.values()</p>
</div></blockquote>
<p>So, only the elements of recent with indices
between min_start and stop need to be retained
in self.recent. These elements are shifted down
by _set_up_next_recent().</p>
<p>2. Waking up agents subscribing to a stream.
When a stream is modified, the stream calls
wakeup_subscribers() which puts the subscribing
agents into a queue in ComputeEngine. This queue is
called q_agents and contains agents waiting for
execution. The main compute thread of the process
(see create_compute_thread() in ComputeEngine)
gets agents from this queue and calls the funcion
next() of each agent.</p>
<dl class="py method">
<dt id="IoTPy.core.stream.Stream.append">
<code class="sig-name descname">append</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.stream.Stream.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append a single value to the end of the stream.</p>
</dd></dl>

<dl class="py method">
<dt id="IoTPy.core.stream.Stream.delete_reader">
<code class="sig-name descname">delete_reader</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">reader</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.stream.Stream.delete_reader" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete this reader from the set of agents that read this
stream.</p>
</dd></dl>

<dl class="py method">
<dt id="IoTPy.core.stream.Stream.delete_subscriber">
<code class="sig-name descname">delete_subscriber</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">agent</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.stream.Stream.delete_subscriber" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete a subscriber for this stream.
Same as delete_caller()</p>
</dd></dl>

<dl class="py method">
<dt id="IoTPy.core.stream.Stream.extend">
<code class="sig-name descname">extend</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">value_list</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.stream.Stream.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Extend the stream by value_list.</p>
<blockquote>
<div><p>value_list: list</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="IoTPy.core.stream.Stream.get_contents_after_column_value">
<code class="sig-name descname">get_contents_after_column_value</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">column_number</span></em>, <em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.stream.Stream.get_contents_after_column_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Assumes that the stream consists of rows where the
number of elements in each row exceeds column_number. Also
assumes that values in the column with index column_number
are in increasing order.</p>
<blockquote>
<div><dl class="simple">
<dt>Returns the rows in the stream for which:</dt><dd><p>row[column_number] &gt;= value</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="IoTPy.core.stream.Stream.get_earliest_index_in_memory">
<code class="sig-name descname">get_earliest_index_in_memory</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">default_for_empty_stream</span><span class="o">=</span><span class="default_value">- 1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.stream.Stream.get_earliest_index_in_memory" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index of the earliest element in the stream
that is in main memory.
If the stream is empty then it returns the default.</p>
</dd></dl>

<dl class="py method">
<dt id="IoTPy.core.stream.Stream.get_elements_after_index">
<code class="sig-name descname">get_elements_after_index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">index</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.stream.Stream.get_elements_after_index" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>index: int</dt><dd><p>index is a pointer to an element in the stream.
(Example: stream has 38 elements, num_in_memory is
10, and index is 35.)</p>
</dd>
</dl>
<blockquote>
<div><p>(pointer, list)
Case 1: if index is greater than the length of
the stream the function returns the tuple:</p>
<blockquote>
<div><p>(length of stream, empty list)</p>
</div></blockquote>
<p>Case 2: index is less than or equal to the stream length.
The function returns the tuple (p, l) where p
is a pointer into the buffer, recent, and l is stream[p:].
In the example where a stream s has 38 elements and
index is 35, l is s[35:39].
If this section of the stream is stored in recent[3:7] then
p is 3.</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="IoTPy.core.stream.Stream.get_index_for_column_value">
<code class="sig-name descname">get_index_for_column_value</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">column_number</span></em>, <em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.stream.Stream.get_index_for_column_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to get_contents_after_column_value except that the
value returned is an index into recent rather than the sequence
of rows.</p>
</dd></dl>

<dl class="py method">
<dt id="IoTPy.core.stream.Stream.get_last_n">
<code class="sig-name descname">get_last_n</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.stream.Stream.get_last_n" title="Permalink to this definition">¶</a></dt>
<dd><p>n : positive integer</p>
<blockquote>
<div><p>The list of the last n elements of the stream. If the
number of elements in the stream is less than n, then
it returns all the elements in the stream.</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="IoTPy.core.stream.Stream.get_latest">
<code class="sig-name descname">get_latest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">default_for_empty_stream</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.stream.Stream.get_latest" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the latest element in the stream.
The latest element is the most recent element put in
the stream.
If the stream is empty then it returns the default.</p>
</dd></dl>

<dl class="py method">
<dt id="IoTPy.core.stream.Stream.get_latest_index">
<code class="sig-name descname">get_latest_index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">default_for_empty_stream</span><span class="o">=</span><span class="default_value">- 1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.stream.Stream.get_latest_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index of the latest element in the stream.
The latest element is the most recent element put in
the stream.
If the stream is empty then it returns the default.</p>
</dd></dl>

<dl class="py method">
<dt id="IoTPy.core.stream.Stream.get_latest_n">
<code class="sig-name descname">get_latest_n</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.stream.Stream.get_latest_n" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as get_last_n()</p>
</dd></dl>

<dl class="py method">
<dt id="IoTPy.core.stream.Stream.is_empty">
<code class="sig-name descname">is_empty</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.stream.Stream.is_empty" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>True if and only if this stream is empty,
i.e., self.len == 0</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="IoTPy.core.stream.Stream.len">
<code class="sig-name descname">len</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.stream.Stream.len" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Number of elements in the stream.</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="IoTPy.core.stream.Stream.operator_overload">
<code class="sig-name descname">operator_overload</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">another_stream</span></em>, <em class="sig-param"><span class="n">func</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.stream.Stream.operator_overload" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="IoTPy.core.stream.Stream.print_recent">
<code class="sig-name descname">print_recent</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.stream.Stream.print_recent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="IoTPy.core.stream.Stream.register_reader">
<code class="sig-name descname">register_reader</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">new_reader</span></em>, <em class="sig-param"><span class="n">start_index</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.stream.Stream.register_reader" title="Permalink to this definition">¶</a></dt>
<dd><p>A newly registered reader starts reading  the stream from
the point start_index.
If reader has already been registered with this stream
its start value is updated to start_index.</p>
</dd></dl>

<dl class="py method">
<dt id="IoTPy.core.stream.Stream.register_subscriber">
<code class="sig-name descname">register_subscriber</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">agent</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.stream.Stream.register_subscriber" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a subscriber for this stream.
Same as call()</p>
</dd></dl>

<dl class="py attribute">
<dt id="IoTPy.core.stream.Stream.scheduler">
<code class="sig-name descname">scheduler</code><em class="property"> = &lt;IoTPy.core.compute_engine.ComputeEngine object&gt;</em><a class="headerlink" href="#IoTPy.core.stream.Stream.scheduler" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="IoTPy.core.stream.Stream.set_name">
<code class="sig-name descname">set_name</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.stream.Stream.set_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="IoTPy.core.stream.Stream.set_start">
<code class="sig-name descname">set_start</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">reader</span></em>, <em class="sig-param"><span class="n">starting_value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.stream.Stream.set_start" title="Permalink to this definition">¶</a></dt>
<dd><p>The reader tells the stream that it is only accessing
elements of the list, recent, with index start or higher.</p>
</dd></dl>

<dl class="py method">
<dt id="IoTPy.core.stream.Stream.wakeup_subscribers">
<code class="sig-name descname">wakeup_subscribers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.stream.Stream.wakeup_subscribers" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="IoTPy.core.stream.StreamArray">
<em class="property">class </em><code class="sig-prename descclassname">IoTPy.core.stream.</code><code class="sig-name descname">StreamArray</code><span class="sig-paren">(</span><em class="sig-param">name='NoName'</em>, <em class="sig-param">dimension=0</em>, <em class="sig-param">dtype=&lt;class 'float'&gt;</em>, <em class="sig-param">initial_value=None</em>, <em class="sig-param">num_in_memory=1048576</em><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.stream.StreamArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#IoTPy.core.stream.Stream" title="IoTPy.core.stream.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">IoTPy.core.stream.Stream</span></code></a></p>
<dl class="py method">
<dt id="IoTPy.core.stream.StreamArray.append">
<code class="sig-name descname">append</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.stream.StreamArray.append" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><dl class="simple">
<dt>value: numpy array</dt><dd><p>The value appended to the StreamArray</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>See self._create_recent() for a description of
the elements of the stream.
This function extends the stream by a single
element, i.e, value.</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="IoTPy.core.stream.StreamArray.extend">
<code class="sig-name descname">extend</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">output_array</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.stream.StreamArray.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>See extend() for the class Stream.
Extend the stream by an numpy array.</p>
<blockquote>
<div><p>output_array: np.array</p>
</div></blockquote>
<blockquote>
<div><p>See self._create_recent() for a description of
the elements of the stream.</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="IoTPy.core.stream.StreamArray.get_contents_after_time">
<code class="sig-name descname">get_contents_after_time</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">start_time</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.stream.StreamArray.get_contents_after_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="IoTPy.core.stream.StreamArray.length">
<code class="sig-name descname">length</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.stream.StreamArray.length" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="IoTPy.core.stream.StreamArray.operator_overload">
<code class="sig-name descname">operator_overload</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">another_stream</span></em>, <em class="sig-param"><span class="n">func</span></em><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.stream.StreamArray.operator_overload" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt id="IoTPy.core.stream.run">
<code class="sig-prename descclassname">IoTPy.core.stream.</code><code class="sig-name descname">run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IoTPy.core.stream.run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-IoTPy.core.system_parameters">
<span id="iotpy-core-system-parameters-module"></span><h2>IoTPy.core.system_parameters module<a class="headerlink" href="#module-IoTPy.core.system_parameters" title="Permalink to this headline">¶</a></h2>
<p>SYSTEM_PARAMETERS</p>
</div>
<div class="section" id="module-IoTPy.core">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-IoTPy.core" title="Permalink to this headline">¶</a></h2>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">IoTPy.core package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-IoTPy.core.agent">IoTPy.core.agent module</a></li>
<li><a class="reference internal" href="#module-IoTPy.core.compute_engine">IoTPy.core.compute_engine module</a></li>
<li><a class="reference internal" href="#module-IoTPy.core.helper_control">IoTPy.core.helper_control module</a></li>
<li><a class="reference internal" href="#module-IoTPy.core.stream">IoTPy.core.stream module</a></li>
<li><a class="reference internal" href="#module-IoTPy.core.system_parameters">IoTPy.core.system_parameters module</a></li>
<li><a class="reference internal" href="#module-IoTPy.core">Module contents</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/source/IoTPy.core.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">IoTPy 1.1.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">IoTPy.core package</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, K. Mani Chandy.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.1.2.
    </div>
  </body>
</html>